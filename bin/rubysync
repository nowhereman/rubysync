#!/usr/bin/env ruby


  # == Synopsis
  # 
  #   Command line tool for running *rubysync* <em>A Free MetaDirectory.</em>
  # 
  # == Usage
  #   
  #     rubysync command name [options]
  #   
  #  Valid commands are::
  #   * create {name}::            Create a rubysync configuration directory
  # 
  #   * connector {name} -t {type} [--vault {name}] [--client {name}]
  #                           ; Create a connector of the given name in
  #                           ; the current rubysync configuration directory
  #                         
  #   * fields {name}           ; list the fields detected by the named connector
  # 
  #   * pipeline {name}         ; Create a rubysync pipeline of the given name
  #                           ; in the current rubysync configuration directory
  #                         
  #   * once {name}::             
  #       Execute the named pipeline within the current configuration directory once and then exit
  #                         
  #   * example::          Show an example of how this command might be used
  # 
  # == Example
  # 
  #   This sets up the skeleton of a configuration for importing comma delimeted
  #   text files into an xml file.
  #     <tt>
  #     $ rubysync create xml_demo
  #     $ cd xml_demo
  #     $ rubysync connector my_csv -t csv_file
  #     $ rubysync connector my_xml -t xml
  #     </tt>
  #   
  #   You would then edit the files::
  # 
  #     * +connectors/my_csv_connector.rb+:: where to get the CSV files, field names, etc
  #     * +connectors/my_xml_connector.rb+::  how to connect to your XML file.
  # 
  #   And enter::
  #     <tt>
  #     $ rubysync pipeline my_pipeline -C my_csv -V my_xml
  #     </tt>
  # 
  #   You would then edit the file +pipelines/my_pipeline.rb+ to configure the
  #   policy for synchronizing between the two connectors.
  #                                         
  #   You may then execute the pipeline in one-shot mode (daemon mode is coming)::
  # 
  #     <tt>
  #     $ rubysync once my_pipeline
  #     </tt>
  # 
  # == Author
  #   Ritchie Young, 9 to 5 Magic (http://9to5magic.com.au)
  #  
  # == Copyright
  #   Copyright (c) 2007 Ritchie Young. All rights reserved.
  # 
  # This file is part of RubySync.
  # 
  # RubySync is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
  # as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
  # 
  # RubySync is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
  # warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
  # 
  # You should have received a copy of the GNU General Public License along with RubySync; if not, write to the
  # Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA


lib_path = File.dirname(__FILE__) + '/../lib'
$:.unshift lib_path unless $:.include?(lib_path) || $:.include?(File.expand_path(lib_path))
require "ruby_sync"
require "simpleconsole"
require 'rdoc/usage'


class Controller < SimpleConsole::Controller

  include RubySync::Utilities

  before_filter :configure_logging
  
  params :string => {:p => :pipe,
                     :t => :type,
                     :V => :vault,
                     :C => :client},
         :int =>{:v => :verbose}

  def default
    #RDoc::usage 'Usage'
  end
  
  def example
    #RDoc::usage 'Example'
  end
  
  # Run specified pipeline once then exit
  def once
    pipeline_name = params[:id]
    pipeline = pipeline_called pipeline_name
    if pipeline
      pipeline.run_once
    else
      log.error "Couldn't find a pipeline called '#{pipeline_name}'"
    end
  end

  def start
    pipeline_name = params[:id]
    pipeline = pipeline_called pipeline_name
    if pipeline
      pipeline.start
    else
      log.error "Couldn't find a pipeline called '#{pipeline_name}'"
    end
  end



  # Create a Rubysync project directory
  def create
    config_path = params[:id]
    ensure_dir_exists([
      config_path,
      "#{config_path}/pipelines",
      "#{config_path}/connectors",
      "#{config_path}/shared",
      "#{config_path}/shared/pipelines",
      "#{config_path}/shared/connectors",
      "#{config_path}/shared/lib",
      "#{config_path}/log",
      "#{config_path}/db"
    ])
  end
  
  # Create a connector configuration file
  def connector
    name = params[:id]
    type = params[:type]
    unless name and type
      puts "Usage: rubysync connector connector_name -t connector_type"
      return
    end
    if base_path
      File.open("#{base_path}/connectors/#{name}_connector.rb", "w") do |file|
        file.puts connector_template(name, type)
      end
    else
      puts 'Change into a config dir and try again or create a config dir with "rubysync create"'
    end
  end

  # List the fields that the named connector can detect. This is
  # a good way to test if a connector config is functional.
  def fields
    connector_name = params[:id]
    connector = (connector_name)? ::RubySync::Connectors::BaseConnector.class_for(connector_name) : nil
    @field_names = connector && connector.fields || []
  end
  
  def pipeline
    name = params[:id]
    vault_name = params[:vault]
    client_name = params[:client]
    unless name
      puts "Usage: rubysync pipeline pipeline_name [-V vault] [-C client]"
      return
    end
    if base_path
      File.open("#{base_path}/pipelines/#{name}_pipeline.rb", "w") do |file|
        file.puts pipeline_template(name, vault_name, client_name)
      end
    else
      puts 'Change into a config dir and try again or create a config dir with "rubysync create"'
    end
    
  end
  
  
  private
  
  def configure_logging
    log_levels = [Logger::WARN, Logger::INFO, Logger::DEBUG]
    verbosity = [(params[:verbose]||0), log_levels.size-1].min
    log.level = log_levels[verbosity]
  end
  
end


class View < SimpleConsole::View


def default
puts <<"END"
Usage:
  
    rubysync command name [options]
  
 Valid commands are:
  * create {name}:            Create a rubysync configuration directory

  * connector {name} -t {type} [--vault {name}] [--client {name}]
                          ; Create a connector of the given name in
                          ; the current rubysync configuration directory
                        
  * fields {name}         ; list the fields detected by the named connector

  * pipeline {name}       ; Create a rubysync pipeline of the given name
                          ; in the current rubysync configuration directory
                        
  * once {name}             
                          ; Execute the named pipeline within the current
                          ; configuration directory once and then exit
                          
  * start {name}          ; Execute the named pipeline
                        
  * example               ; Show an example of how this command might be used

END
end


def example
puts <<"END"
  This sets up the skeleton of a configuration for importing comma delimeted
  text files into a database. Note, if the application happens to be a Rails
  app then it can also export changes.

    $ rubysync create db_demo
    $ cd db_demo
    $ rubysync connector my_csv -t csv_file
    $ rubysync connector my_db -t active_record
  
  You would then edit the files:

    connectors/my_csv_connector.rb   ;where to get CSV files, field names, etc
    connectors/my_db_connector.rb    ;how to connect to your DB or Rails app.

  And enter:
    $ rubysync pipeline my -C my_csv -V my_db

  You would then edit the file pipelines/my_pipeline.rb to configure the
  policy for synchronizing between the two connectors.
                                        
  You may then execute the pipeline in one-shot mode:

    $ rubysync once my
    
  or continually:
  
    $ rubysync start my
END
end

def fields
  puts @field_names.join("\n")
end

                                            
  

end


  def connector_template name, type
    type_class_name = "RubySync::Connectors::#{type.to_s.camelize}Connector"
    type_class = eval(type_class_name)
    sample_config = (type_class && type_class.respond_to?("sample_config")) ?
      type_class.sample_config : ""
    return <<-"end;"
class #{name.to_s.camelize}Connector < #{type_class_name}
  #{sample_config}
end
    end;
  end

  
  def pipeline_template name, vault_name, client_name
    vault = (vault_name)? ::RubySync::Connectors::BaseConnector.class_for(vault_name) : nil
    vault_fields = vault && vault.fields || %w{allow these fields through}
    possible_fields = (vault_fields.map {|n| ":#{n}"}).join(", ")

    client = (client_name)? ::RubySync::Connectors::BaseConnector.class_for(client_name) : nil
    client_fields = client && client.fields || []

    vault_specifier = (vault_name)? "vault :#{vault_name}" : "#vault :vault_connector_name"
    client_specifier = (client_name)? "client :#{client_name}" : "#client :client_connector_name"
    return <<-"end;"
class #{name.to_s.camelize}Pipeline < RubySync::Pipelines::BasePipeline

  #{client_specifier}

  #{vault_specifier}

  # Remove any fields that you don't want to set in the client from the vault
  allow_out #{possible_fields}

  # Remove any fields that you don't want to set in the vault from the client
  allow_in #{possible_fields}

  # If the client and vault have different names for the same field, define the
  # the mapping here. For example, if the vault has a field called "first name" and
  # the client has a field called givenName you may put:
  #    'first name' => 'givenName'
  # separate each mapping with a comma.
  # The following fields were detected on the client:
  # #{(client_fields.map {|f| "'#{f}'"}).join(",")}
  map_vault_to_client({
    #{(vault_fields.map {|f| "#'#{f}' => 'a_client_field'"}).join(",\n\t\t")}
  })

  # "in" means going from client to vault
  #in_transform do
  #end

  # "out" means going from vault to client
  #out_transform do
  #end

end
    end;
  end


SimpleConsole::Application.run(ARGV, Controller, View)
